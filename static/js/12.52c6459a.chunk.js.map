{"version":3,"sources":["hooks/useEventListener.js","exp/Exp12.js","hooks/useSmallSize.js"],"names":["eventName","handler","element","window","savedHandler","useRef","useEffect","current","addEventListener","eventListener","event","removeEventListener","size","useSmallSize","canvas","requestRef","dark","useContext","ThemeContext","requestAnimationFrame","animationLoop","cancelAnimationFrame","dx","dy","x","y","paddleX","rightPressed","leftPressed","brickOffsetLeft","brickPadding","score","lives","handleKeyDown","useCallback","keyCode","handleKeyUp","useEventListener","relativeX","clientX","offsetLeft","paddleWidth","colors","main","bricks","c","r","status","ctx","getContext","clearRect","beginPath","fillStyle","arc","Math","PI","fill","closePath","drawBall","rect","drawPaddle","brickX","brickY","drawBricks","b","brickRowCount","console","log","document","location","reload","collisionDetection","font","fillText","drawScore","drawLives","style","width","height","display","justifyContent","alignItems","border","ref","devicePixelRatio","isClient","getSize","innerWidth","innerHeight","undefined","useState","windowSize","setWindowSize","handleResize"],"mappings":"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","file":"static/js/12.52c6459a.chunk.js","sourcesContent":["import { useState, useRef, useEffect, useCallback } from 'react';\n\n// Hook\nexport default (eventName, handler, element = window) => {\n  // Create a ref that stores handler\n  const savedHandler = useRef();\n\n  // Update ref.current value if handler changes.\n  // This allows our effect below to always get latest handler ...\n  // ... without us needing to pass it in effect deps array ...\n  // ... and potentially cause effect to re-run every render.\n  useEffect(() => {\n    savedHandler.current = handler;\n  }, [handler]);\n\n  useEffect(\n    () => {\n      // Make sure element supports addEventListener\n      // On\n      const isSupported = element && element.addEventListener;\n      if (!isSupported) return;\n\n      // Create event listener that calls handler function stored in ref\n      const eventListener = event => savedHandler.current(event);\n\n      // Add event listener\n      element.addEventListener(eventName, eventListener);\n\n      // Remove event listener on cleanup\n      return () => {\n        element.removeEventListener(eventName, eventListener);\n      };\n    },\n    [eventName, element] // Re-run if eventName or element changes\n  );\n};","import React, { useEffect, useContext, useCallback, useRef } from \"react\";\nimport useEventListener from \"../hooks/useEventListener\";\nimport useSmallSize from \"../hooks/useSmallSize\";\nimport ThemeContext from \"../context/ThemeContext\";\n\nexport default () => {\n  const size = useSmallSize();\n  const canvas = useRef(null);\n  const requestRef = useRef();\n  const { dark } = useContext(ThemeContext);\n\n  useEffect(() => {\n    requestRef.current = requestAnimationFrame(animationLoop);\n    return () => cancelAnimationFrame(requestRef.current);\n  }); // Make sure the effect runs only once\n\n  // Ball\n  const ballRadius = 10;\n  let dx = 4;\n  let dy = -4;\n  let x = size / 2;\n  let y = size - 200;\n\n  // Paddle\n  let paddleHeight = 20;\n  let paddleWidth = 75;\n  let paddleX = size / 2;\n  let paddleY = 100;\n\n  // Controls\n  let rightPressed = false;\n  let leftPressed = false;\n\n  // Bricks\n  let brickRowCount = 4;\n  let brickColumnCount = 4;\n  let brickWidth = 75;\n  let brickHeight = 20;\n  let brickPadding = 10;\n  let brickOffsetTop = 100;\n  let brickOffsetLeft =\n    size / 2 -\n    ((brickWidth + brickPadding) * brickColumnCount) / 2 +\n    brickPadding / 2;\n\n  // State\n  let score = 0;\n  let lives = 3;\n\n  // Handlers\n  const handleKeyDown = useCallback(({ keyCode }) => {\n    if (keyCode === 39) {\n      rightPressed = true;\n    } else if (keyCode === 37) {\n      leftPressed = true;\n    }\n  }, []);\n\n  const handleKeyUp = useCallback(({ keyCode }) => {\n    if (keyCode === 39) {\n      rightPressed = false;\n    } else if (keyCode === 37) {\n      leftPressed = false;\n    }\n  }, []);\n\n  function handleMouse({ clientX }) {\n    let relativeX = clientX - canvas.current.offsetLeft;\n    if (relativeX > 0 && relativeX < size) {\n      paddleX = relativeX - paddleWidth / 2;\n    }\n  }\n\n  // Add event listener using our hook\n  useEventListener(\"keydown\", handleKeyDown);\n  useEventListener(\"keyup\", handleKeyUp);\n  useEventListener(\"mousemove\", handleMouse);\n\n  function collisionDetection() {\n    for (c = 0; c < brickColumnCount; c++) {\n      for (r = 0; r < brickRowCount; r++) {\n        let b = bricks[c][r];\n        if (b.status === 1) {\n          if (\n            x > b.x &&\n            x < b.x + brickWidth &&\n            y > b.y &&\n            y < b.y + brickHeight\n          ) {\n            dy = -dy;\n            b.status = 0;\n            score++;\n            if (score === brickRowCount * brickColumnCount) {\n              console.log(\"YOU WIN\");\n              document.location.reload();\n            }\n          }\n        }\n      }\n    }\n  }\n\n  function drawScore(ctx) {\n    ctx.font = \"bold 30px Inter\";\n    ctx.fillStyle = colors.main;\n    ctx.fillText(score, 35, 40);\n  }\n  function drawLives(ctx) {\n    ctx.fillText(lives, size - 65, 40);\n  }\n\n  // Colors\n  const colors = {\n    main: dark ? \"RGBA(228, 230, 234, 1.00)\" : \"RGBA(62, 62, 62, 1.00)\",\n  };\n\n  let bricks = [];\n  for (var c = 0; c < brickColumnCount; c++) {\n    bricks[c] = [];\n    for (var r = 0; r < brickRowCount; r++) {\n      bricks[c][r] = { x: 0, y: 0, status: 1 };\n    }\n  }\n\n  const drawBall = (ctx) => {\n    ctx.beginPath();\n    ctx.fillStyle = colors.main;\n    ctx.arc(x, y, ballRadius, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.closePath();\n  };\n\n  const drawPaddle = (ctx) => {\n    ctx.beginPath();\n    ctx.rect(paddleX, size - paddleY, paddleWidth, paddleHeight);\n    ctx.fillStyle = colors.main;\n    ctx.fill();\n    ctx.closePath();\n  };\n\n  const drawBricks = (ctx) => {\n    for (var c = 0; c < brickColumnCount; c++) {\n      for (var r = 0; r < brickRowCount; r++) {\n        if (bricks[c][r].status === 1) {\n          let brickX = c * (brickWidth + brickPadding) + brickOffsetLeft;\n          let brickY = r * (brickHeight + brickPadding) + brickOffsetTop;\n          bricks[c][r].x = brickX;\n          bricks[c][r].y = brickY;\n          ctx.beginPath();\n          ctx.rect(brickX, brickY, brickWidth, brickHeight);\n          ctx.fillStyle = colors.main;\n          ctx.fill();\n          ctx.closePath();\n        }\n      }\n    }\n  };\n\n  // DRAW\n  const animationLoop = () => {\n    const ctx = canvas.current.getContext(\"2d\");\n\n    ctx.clearRect(0, 0, size, size); // clear canvas\n\n    drawBall(ctx);\n    drawPaddle(ctx);\n    drawBricks(ctx);\n    collisionDetection();\n    drawScore(ctx);\n    drawLives(ctx);\n\n    // Mov\n    x += dx;\n    y += dy;\n\n    if (x + dx > size - ballRadius || x + dx < ballRadius) {\n      dx = -dx;\n    }\n    if (y + dy < ballRadius) {\n      dy = -dy;\n    } else if (y + dy + paddleY > size - ballRadius) {\n      // Paddle\n      if (x > paddleX && x < paddleX + paddleWidth) {\n        dy = -dy;\n      } else {\n        lives--;\n        if (!lives) {\n          console.log(\"GAME OVER\");\n          document.location.reload();\n        } else {\n          x = size / 2;\n          y = size / 2;\n          dx = 3;\n          dy = -3;\n          paddleX = (size - paddleWidth) / 2;\n        }\n      }\n    }\n\n    if (rightPressed && paddleX < size - paddleWidth) {\n      paddleX += 7;\n    } else if (leftPressed && paddleX > 0) {\n      paddleX -= 7;\n    }\n\n    // console.log(y > size - paddleY)\n\n    // Loop\n    requestRef.current = requestAnimationFrame(animationLoop);\n  };\n\n  return (\n    <div\n      style={{\n        width: \"100%\",\n        height: \"100vh\",\n        display: \"flex\",\n        justifyContent: \"center\",\n        alignItems: \"center\",\n      }}\n    >\n      <canvas\n        style={{\n          size: \"100%\",\n          border: `${paddleHeight}px solid ${colors.main}`,\n        }}\n        ref={canvas}\n        width={size * window.devicePixelRatio || 1}\n        height={size * window.devicePixelRatio || 1}\n      />\n    </div>\n  );\n};\n","import { useState, useEffect } from 'react';\n\nfunction useSmallSize() {\n  const isClient = typeof window === 'object';\n\n  function getSize() {\n    return isClient ? window.innerWidth > window.innerHeight ? window.innerHeight : window.innerWidth : undefined;\n  }\n\n  const [windowSize, setWindowSize] = useState(getSize);\n\n  useEffect(() => {\n    if (!isClient) {\n      return false;\n    }\n\n    function handleResize() {\n      setWindowSize(getSize());\n    }\n\n    window.addEventListener('resize', handleResize);\n    return () => window.removeEventListener('resize', handleResize);\n  }, []); // Empty array ensures that effect is only run on mount and unmount\n\n  return windowSize;\n}\n\nexport default useSmallSize;"],"sourceRoot":""}