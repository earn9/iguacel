{"version":3,"sources":["exp/Exp6.js","../node_modules/threejs-meshline/src/index.js"],"names":["extend","meshline","Rig","mouse","camera","useThree","useFrame","position","x","current","y","lookAt","colors","vertex","radius","vertices","j","Math","PI","push","THREE","cos","sin","LineMesh","width","color","speed","material","useRef","uniforms","dashOffset","value","attach","opacity","ref","transparent","depthTest","lineWidth","dashArray","dashRatio","Lines","count","useMemo","Array","fill","map","_","i","parseInt","length","random","max","props","index","key","bg","useContext","ThemeContext","dark","style","display","justifyContent","alignItems","flexFlow","zIndex","height","cursor","background","near","far","fov","onMouseMove","e","clientX","window","innerWidth","clientY","innerHeight","this","require","Error","MeshLine","BufferGeometry","call","type","positions","previous","next","side","indices_array","uvs","counters","_vertices","_bufferArray","widthCallback","matrixWorld","Matrix4","Object","defineProperties","geometry","enumerable","get","set","setFromGeometry","setVertices","bufferArray","setBufferArray","MeshLineRaycast","raycaster","intersects","inverseMatrix","ray","Ray","sphere","Sphere","interRay","Vector3","copy","boundingSphere","applyMatrix4","intersectSphere","getInverse","vStart","vEnd","interSegment","step","LineSegments","attributes","indices","array","widths","l","a","b","fromArray","undefined","floor","precision","linePrecision","precisionSq","distanceSqToSegment","distance","origin","distanceTo","point","clone","face","faceIndex","object","memcpy","src","srcOffset","dst","dstOffset","subarray","slice","buffer","MeshLineMaterial","parameters","ShaderMaterial","assign","UniformsLib","fog","useMap","alphaMap","useAlphaMap","Color","resolution","Vector2","sizeAttenuation","useDash","visibility","alphaTest","repeat","vertexShader","ShaderChunk","meshline_vert","fragmentShader","meshline_frag","setValues","prototype","create","constructor","isMeshLine","setMatrixWorld","g","c","Geometry","getAttribute","Float32Array","setGeometry","vts","wcb","v","z","process","ba","raycast","compareV3","aa","ab","copyV3","w","n","_attributes","copyArray","needsUpdate","uv","Uint16Array","BufferAttribute","addAttribute","setIndex","computeBoundingSphere","computeBoundingBox","advance","logdepthbuf_pars_vertex","fog_pars_vertex","logdepthbuf_vertex","fog_vertex","join","fog_pars_fragment","logdepthbuf_pars_fragment","logdepthbuf_fragment","fog_fragment","isMeshLineMaterial","source","module","exports"],"mappings":"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SG,EAC5B2E,EAAU8C,EAAI,GAAK5H,EAAS2L,EAC5B7G,EAAU8C,EAAI,GAAK5H,EAASC,EAC5B6E,EAAU8C,EAAI,GAAK5H,EAASG,EAC5B2E,EAAU8C,EAAI,GAAK5H,EAAS2L,EAG5B7C,EAAOhE,EAAW,EAAGE,EAAM,EAAG4C,EAAI,GAElC5C,EAAK4C,EAAI,GAAK5H,EAASC,EACvB+E,EAAK4C,EAAI,GAAK5H,EAASG,EACvB6E,EAAK4C,EAAI,GAAK5H,EAAS2L,EACvB3G,EAAK4C,EAAI,GAAK5H,EAASC,EACvB+E,EAAK4C,EAAI,GAAK5H,EAASG,EACvB6E,EAAK4C,EAAI,GAAK5H,EAAS2L,EAEvBpH,KAAK8H,YAAYrM,SAASuM,aAAc,EACxChI,KAAK8H,YAAYtH,SAASwH,aAAc,EACxChI,KAAK8H,YAAYrH,KAAKuH,aAAc,GAGtC1L,EAAM2J,YAAN,cAAqC,CACnC,GACA3J,EAAM2J,YAAYwC,wBAClBnM,EAAM2J,YAAYyC,gBAClB,GACA,2BACA,uBACA,wBACA,yBACA,4BACA,GACA,2BACA,2BACA,sBACA,yBACA,sBACA,qBACA,iCACA,GACA,oBACA,uBACA,2BACA,GACA,qCACA,GACA,6BACA,uBACA,2BACA,kBACA,GACA,IACA,GACA,gBACA,GACA,kDACA,GACA,uCACA,gBACA,GACA,mDACA,sDACA,gDACA,4CACA,GACA,oDACA,2CACA,2CACA,GACA,mCACA,GACA,gBACA,mEACA,wEACA,aACA,qDACA,qDACA,0CACA,GACA,+CACA,8CACA,6EACA,GACA,QACA,GACA,2EACA,mDACA,2BACA,kCACA,oCACA,wCACA,6EACA,QACA,GACA,wDACA,qCACA,GACA,mCACA,GACApM,EAAM2J,YAAY0C,mBAClBrM,EAAM2J,YAAY2C,YAAc,iEAChCtM,EAAM2J,YAAY2C,WAClB,KACAC,KAAK,QAEPvM,EAAM2J,YAAN,cAAqC,CACnC,GACA3J,EAAM2J,YAAY6C,kBAClBxM,EAAM2J,YAAY8C,0BAClB,GACA,yBACA,8BACA,wBACA,6BACA,yBACA,2BACA,4BACA,2BACA,4BACA,2BACA,uBACA,GACA,oBACA,uBACA,2BACA,GACA,gBACA,GACAzM,EAAM2J,YAAY+C,qBAClB,GACA,uBACA,8DACA,4EACA,qCACA,2BACA,yFACA,QACA,wBACA,qDACA,GACA1M,EAAM2J,YAAYgD,aAClB,KACAJ,KAAK,QAyMP9D,EAAiBuB,UAAYnF,OAAOoF,OAAOjK,EAAM2I,eAAeqB,WAChEvB,EAAiBuB,UAAUE,YAAczB,EACzCA,EAAiBuB,UAAU4C,oBAAqB,EAEhDnE,EAAiBuB,UAAU/D,KAAO,SAAS4G,GAsBzC,OArBA7M,EAAM2I,eAAeqB,UAAU/D,KAAKlC,KAAKL,KAAMmJ,GAE/CnJ,KAAKzC,UAAY4L,EAAO5L,UACxByC,KAAKjC,IAAMoL,EAAOpL,IAClBiC,KAAKqF,OAAS8D,EAAO9D,OACrBrF,KAAKsF,SAAW6D,EAAO7D,SACvBtF,KAAKuF,YAAc4D,EAAO5D,YAC1BvF,KAAKrD,MAAM4F,KAAK4G,EAAOxM,OACvBqD,KAAK7C,QAAUgM,EAAOhM,QACtB6C,KAAKyF,WAAWlD,KAAK4G,EAAO1D,YAC5BzF,KAAK2F,gBAAkBwD,EAAOxD,gBAC9B3F,KAAKV,KAAO6J,EAAO7J,KACnBU,KAAKT,IAAM4J,EAAO5J,IAClBS,KAAKxC,UAAU+E,KAAK4G,EAAO3L,WAC3BwC,KAAKhD,WAAWuF,KAAK4G,EAAOnM,YAC5BgD,KAAKvC,UAAU8E,KAAK4G,EAAO1L,WAC3BuC,KAAK4F,QAAUuD,EAAOvD,QACtB5F,KAAK6F,WAAasD,EAAOtD,WACzB7F,KAAK8F,UAAYqD,EAAOrD,UACxB9F,KAAK+F,OAAOxD,KAAK4G,EAAOpD,QAEjB/F,MAI8BoJ,EAAOC,UAC1CA,EAAUD,EAAOC,QAAU,CACzBlJ,SAAUA,EACV4E,iBAAkBA,EAClBlD,gBAAiBA,IAGrBwH,EAAQlJ,SAAWA,EACnBkJ,EAAQtE,iBAAmBA,EAC3BsE,EAAQxH,gBAAkBA,IAM5BxB,KAAKL","file":"static/js/14.d18233f1.chunk.js","sourcesContent":["import React, { useMemo, useRef, useContext } from \"react\";\nimport * as THREE from \"three\";\nimport * as meshline from \"threejs-meshline\";\nimport { extend, Canvas, useFrame, useThree } from \"react-three-fiber\";\nimport ThemeContext from \"../context/ThemeContext\";\n\nextend(meshline);\n\nconst Rig = ({ mouse }) => {\n  const { camera } = useThree();\n  useFrame(() => {\n    camera.position.x += (-mouse.current[0] / 50 - camera.position.x) * 0.05;\n    camera.position.y += (mouse.current[1] / 50 - camera.position.y) * 0.05;\n    camera.lookAt(0, 0, 0);\n  });\n  return null;\n};\n\nconst colors = [\n  \"#CAE8E6\",\n  \"#EFDE0B\",\n  \"#F39A02\",\n  \"#F04902\",\n  \"#C81412\",\n  \"#780235\",\n  \"#401238\",\n  \"#1E0D2A\",\n  \"#130E11\",\n  \"#0D0B0E\",\n];\n\nconst vertex = (radius = 1) => {\n  const vertices = [];\n  for (let j = 0; j < Math.PI * 2; j += (2 * Math.PI) / 200) {\n    vertices.push(\n      new THREE.Vector3(\n        Math.cos(j) * radius,\n        Math.sin(j) * radius,\n        Math.sin(radius)\n      )\n    );\n  }\n  return vertices;\n};\n\nconst LineMesh = ({ width, color, speed, radius }) => {\n  const material = useRef();\n\n  useFrame(() => (material.current.uniforms.dashOffset.value -= speed));\n\n  return (\n    <mesh>\n      <meshLine attach=\"geometry\" vertices={vertex(radius)} />\n      <meshLineMaterial\n        opacity={0.9}\n        attach=\"material\"\n        ref={material}\n        transparent\n        depthTest={false}\n        lineWidth={width}\n        color={color}\n        dashArray={0.2}\n        dashRatio={0.9}\n      />\n    </mesh>\n  );\n};\n\nconst Lines = ({ count, colors, radius }) => {\n  const lines = useMemo(\n    () =>\n      new Array(count).fill().map((_, i) => {\n        return {\n          color: colors[parseInt(colors.length * Math.random())],\n          width: 0.1,\n          speed: Math.max(0.0001, 0.0012 * Math.random())\n        };\n      }),\n    [colors, count]\n  );\n  return lines.map((props, index) => (\n    <LineMesh key={`lineMesh${index}`} radius={radius} {...props} />\n  ));\n};\n\nexport default function () {\n  const mouse = useRef([0, 0]);\n  const { dark } = useContext(ThemeContext);\n  const bg = dark ? \"#141920\" : \"#ECECDE\";\n\n  return (\n    <div\n      style={{\n        display: \"flex\",\n        justifyContent: \"center\",\n        alignItems: \"center\",\n        flexFlow: \"column\",\n        zIndex: 3,\n        width: \"100%\",\n        height: \"100vh\",\n        cursor: \"pointer\",\n        background: bg\n      }}\n    >\n      <Canvas\n        camera={{ position: [0, 0, 10], near: 0.01, far: 25, fov: 25 }}\n        onMouseMove={e =>\n          (mouse.current = [\n            e.clientX - window.innerWidth / 2,\n            e.clientY - window.innerHeight / 2\n          ])\n        }\n      >\n        {new Array(10).fill().map((x, i) => {\n          return (\n            <Lines\n              key={`line${i}`}\n              count={i < 1 ? 0 : i + 2}\n              colors={colors}\n              radius={i * 0.4 + 0.2}\n            />\n          );\n        })}\n        <Rig mouse={mouse} />\n      </Canvas>\n    </div>\n  );\n}\n",";(function() {\n  'use strict'\n\n  var root = this\n\n  var has_require = typeof require !== 'undefined'\n\n  var THREE = root.THREE || (has_require && require('three'))\n  if (!THREE) throw new Error('MeshLine requires three.js')\n\n  function MeshLine() {\n    THREE.BufferGeometry.call(this)\n    this.type = 'MeshLine'\n\n    this.positions = []\n\n    this.previous = []\n    this.next = []\n    this.side = []\n    this.width = []\n    this.indices_array = []\n    this.uvs = []\n    this.counters = []\n    this._vertices = []\n    this._bufferArray = []\n\n    this.widthCallback = null\n\n    // Used to raycast\n    this.matrixWorld = new THREE.Matrix4()\n\n    // to support previous api\n    Object.defineProperties(this, {\n      geometry: {\n        enumerable: true,\n        get: function() {\n          return this\n        },\n        set: function(value) {\n          this.setFromGeometry(value)\n        },\n      },\n      vertices: {\n        enumerable: true,\n        get: function() {\n          return this._vertices\n        },\n        set: function(value) {\n          this.setVertices(value)\n        },\n      },\n      bufferArray: {\n        enumerable: true,\n        get: function() {\n          return this._bufferArray\n        },\n        set: function(value) {\n          this.setBufferArray(value)\n        },\n      },\n    })\n  }\n\n  MeshLine.prototype = Object.create(THREE.BufferGeometry.prototype)\n  MeshLine.prototype.constructor = MeshLine\n  MeshLine.prototype.isMeshLine = true\n\n  MeshLine.prototype.setMatrixWorld = function(matrixWorld) {\n    this.matrixWorld = matrixWorld\n  }\n\n  MeshLine.prototype.setFromGeometry = function(g, c) {\n    if (g instanceof THREE.Geometry) {\n      this.setVertices(g.vertices, c)\n    }\n    if (g instanceof THREE.BufferGeometry) {\n      this.setBufferArray(g.getAttribute('position').array, c)\n    }\n    if (g instanceof Float32Array || g instanceof Array) {\n      // to support previous api\n      this.setBufferArray(g, c)\n    }\n  }\n\n  // to support previous api\n  MeshLine.prototype.setGeometry = function(g, c) {\n    this.setFromGeometry(g, c)\n  }\n\n  MeshLine.prototype.setVertices = function(vts, wcb) {\n    this._vertices = vts\n    this.widthCallback = wcb || this.widthCallback\n    this.positions = []\n    this.counters = []\n    for (var j = 0; j < vts.length; j++) {\n      var v = vts[j]\n      var c = j / vts.length\n      this.positions.push(v.x, v.y, v.z)\n      this.positions.push(v.x, v.y, v.z)\n      this.counters.push(c)\n      this.counters.push(c)\n    }\n    this.process()\n  }\n\n  MeshLine.prototype.setBufferArray = function(ba, wcb) {\n    this._bufferArray = ba\n    this.widthCallback = wcb || this.widthCallback\n    this.positions = []\n    this.counters = []\n    for (var j = 0; j < ba.length; j += 3) {\n      var c = j / ba.length\n      this.positions.push(ba[j], ba[j + 1], ba[j + 2])\n      this.positions.push(ba[j], ba[j + 1], ba[j + 2])\n      this.counters.push(c)\n      this.counters.push(c)\n    }\n    this.process()\n  }\n\n  function MeshLineRaycast(raycaster, intersects) {\n    var inverseMatrix = new THREE.Matrix4()\n    var ray = new THREE.Ray()\n    var sphere = new THREE.Sphere()\n    var interRay = new THREE.Vector3()\n    var geometry = this.geometry\n    // Checking boundingSphere distance to ray\n\n    sphere.copy(geometry.boundingSphere)\n    sphere.applyMatrix4(this.matrixWorld)\n\n    if (raycaster.ray.intersectSphere(sphere, interRay) === false) {\n      return\n    }\n\n    inverseMatrix.getInverse(this.matrixWorld)\n    ray.copy(raycaster.ray).applyMatrix4(inverseMatrix)\n\n    var vStart = new THREE.Vector3()\n    var vEnd = new THREE.Vector3()\n    var interSegment = new THREE.Vector3()\n    var step = this instanceof THREE.LineSegments ? 2 : 1\n    var index = geometry.index\n    var attributes = geometry.attributes\n\n    if (index !== null) {\n      var indices = index.array\n      var positions = attributes.position.array\n      var widths = attributes.width.array\n\n      for (var i = 0, l = indices.length - 1; i < l; i += step) {\n        var a = indices[i]\n        var b = indices[i + 1]\n\n        vStart.fromArray(positions, a * 3)\n        vEnd.fromArray(positions, b * 3)\n        var width = widths[Math.floor(i / 3)] != undefined ? widths[Math.floor(i / 3)] : 1\n        var precision = raycaster.linePrecision + (this.material.lineWidth * width) / 2\n        var precisionSq = precision * precision\n\n        var distSq = ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment)\n\n        if (distSq > precisionSq) continue\n\n        interRay.applyMatrix4(this.matrixWorld) //Move back to world space for distance calculation\n\n        var distance = raycaster.ray.origin.distanceTo(interRay)\n\n        if (distance < raycaster.near || distance > raycaster.far) continue\n\n        intersects.push({\n          distance: distance,\n          // What do we want? intersection point on the ray or on the segment??\n          // point: raycaster.ray.at( distance ),\n          point: interSegment.clone().applyMatrix4(this.matrixWorld),\n          index: i,\n          face: null,\n          faceIndex: null,\n          object: this,\n        })\n        // make event only fire once\n        i = l\n      }\n    }\n  }\n  MeshLine.prototype.raycast = MeshLineRaycast\n  MeshLine.prototype.compareV3 = function(a, b) {\n    var aa = a * 6\n    var ab = b * 6\n    return (\n      this.positions[aa] === this.positions[ab] &&\n      this.positions[aa + 1] === this.positions[ab + 1] &&\n      this.positions[aa + 2] === this.positions[ab + 2]\n    )\n  }\n\n  MeshLine.prototype.copyV3 = function(a) {\n    var aa = a * 6\n    return [this.positions[aa], this.positions[aa + 1], this.positions[aa + 2]]\n  }\n\n  MeshLine.prototype.process = function() {\n    var l = this.positions.length / 6\n\n    this.previous = []\n    this.next = []\n    this.side = []\n    this.width = []\n    this.indices_array = []\n    this.uvs = []\n\n    var w\n\n    var v\n    // initial previous points\n    if (this.compareV3(0, l - 1)) {\n      v = this.copyV3(l - 2)\n    } else {\n      v = this.copyV3(0)\n    }\n    this.previous.push(v[0], v[1], v[2])\n    this.previous.push(v[0], v[1], v[2])\n\n    for (var j = 0; j < l; j++) {\n      // sides\n      this.side.push(1)\n      this.side.push(-1)\n\n      // widths\n      if (this.widthCallback) w = this.widthCallback(j / (l - 1))\n      else w = 1\n      this.width.push(w)\n      this.width.push(w)\n\n      // uvs\n      this.uvs.push(j / (l - 1), 0)\n      this.uvs.push(j / (l - 1), 1)\n\n      if (j < l - 1) {\n        // points previous to poisitions\n        v = this.copyV3(j)\n        this.previous.push(v[0], v[1], v[2])\n        this.previous.push(v[0], v[1], v[2])\n\n        // indices\n        var n = j * 2\n        this.indices_array.push(n, n + 1, n + 2)\n        this.indices_array.push(n + 2, n + 1, n + 3)\n      }\n      if (j > 0) {\n        // points after poisitions\n        v = this.copyV3(j)\n        this.next.push(v[0], v[1], v[2])\n        this.next.push(v[0], v[1], v[2])\n      }\n    }\n\n    // last next point\n    if (this.compareV3(l - 1, 0)) {\n      v = this.copyV3(1)\n    } else {\n      v = this.copyV3(l - 1)\n    }\n    this.next.push(v[0], v[1], v[2])\n    this.next.push(v[0], v[1], v[2])\n\n    // redefining the attribute seems to prevent range errors \n    // if the user sets a differing number of vertices\n    if (!this._attributes || this._attributes.position.count !== this.positions.length) {\n      this._attributes = {\n        position: new THREE.BufferAttribute(new Float32Array(this.positions), 3),\n        previous: new THREE.BufferAttribute(new Float32Array(this.previous), 3),\n        next: new THREE.BufferAttribute(new Float32Array(this.next), 3),\n        side: new THREE.BufferAttribute(new Float32Array(this.side), 1),\n        width: new THREE.BufferAttribute(new Float32Array(this.width), 1),\n        uv: new THREE.BufferAttribute(new Float32Array(this.uvs), 2),\n        index: new THREE.BufferAttribute(new Uint16Array(this.indices_array), 1),\n        counters: new THREE.BufferAttribute(new Float32Array(this.counters), 1),\n      }\n    } else {\n      this._attributes.position.copyArray(new Float32Array(this.positions))\n      this._attributes.position.needsUpdate = true\n      this._attributes.previous.copyArray(new Float32Array(this.previous))\n      this._attributes.previous.needsUpdate = true\n      this._attributes.next.copyArray(new Float32Array(this.next))\n      this._attributes.next.needsUpdate = true\n      this._attributes.side.copyArray(new Float32Array(this.side))\n      this._attributes.side.needsUpdate = true\n      this._attributes.width.copyArray(new Float32Array(this.width))\n      this._attributes.width.needsUpdate = true\n      this._attributes.uv.copyArray(new Float32Array(this.uvs))\n      this._attributes.uv.needsUpdate = true\n      this._attributes.index.copyArray(new Uint16Array(this.indices_array))\n      this._attributes.index.needsUpdate = true\n    }\n\n    this.addAttribute('position', this._attributes.position)\n    this.addAttribute('previous', this._attributes.previous)\n    this.addAttribute('next', this._attributes.next)\n    this.addAttribute('side', this._attributes.side)\n    this.addAttribute('width', this._attributes.width)\n    this.addAttribute('uv', this._attributes.uv)\n    this.addAttribute('counters', this._attributes.counters)\n\n    this.setIndex(this._attributes.index)\n\n    this.computeBoundingSphere()\n    this.computeBoundingBox()\n  }\n\n  function memcpy(src, srcOffset, dst, dstOffset, length) {\n    var i\n\n    src = src.subarray || src.slice ? src : src.buffer\n    dst = dst.subarray || dst.slice ? dst : dst.buffer\n\n    src = srcOffset\n      ? src.subarray\n        ? src.subarray(srcOffset, length && srcOffset + length)\n        : src.slice(srcOffset, length && srcOffset + length)\n      : src\n\n    if (dst.set) {\n      dst.set(src, dstOffset)\n    } else {\n      for (i = 0; i < src.length; i++) {\n        dst[i + dstOffset] = src[i]\n      }\n    }\n\n    return dst\n  }\n\n  /**\n   * Fast method to advance the line by one position.  The oldest position is removed.\n   * @param position\n   */\n  MeshLine.prototype.advance = function(position) {\n    var positions = this._attributes.position.array\n    var previous = this._attributes.previous.array\n    var next = this._attributes.next.array\n    var l = positions.length\n\n    // PREVIOUS\n    memcpy(positions, 0, previous, 0, l)\n\n    // POSITIONS\n    memcpy(positions, 6, positions, 0, l - 6)\n\n    positions[l - 6] = position.x\n    positions[l - 5] = position.y\n    positions[l - 4] = position.z\n    positions[l - 3] = position.x\n    positions[l - 2] = position.y\n    positions[l - 1] = position.z\n\n    // NEXT\n    memcpy(positions, 6, next, 0, l - 6)\n\n    next[l - 6] = position.x\n    next[l - 5] = position.y\n    next[l - 4] = position.z\n    next[l - 3] = position.x\n    next[l - 2] = position.y\n    next[l - 1] = position.z\n\n    this._attributes.position.needsUpdate = true\n    this._attributes.previous.needsUpdate = true\n    this._attributes.next.needsUpdate = true\n  }\n\n  THREE.ShaderChunk['meshline_vert'] = [\n    '',\n    THREE.ShaderChunk.logdepthbuf_pars_vertex,\n    THREE.ShaderChunk.fog_pars_vertex,\n    '',\n    'attribute vec3 previous;',\n    'attribute vec3 next;',\n    'attribute float side;',\n    'attribute float width;',\n    'attribute float counters;',\n    '',\n    'uniform vec2 resolution;',\n    'uniform float lineWidth;',\n    'uniform vec3 color;',\n    'uniform float opacity;',\n    'uniform float near;',\n    'uniform float far;',\n    'uniform float sizeAttenuation;',\n    '',\n    'varying vec2 vUV;',\n    'varying vec4 vColor;',\n    'varying float vCounters;',\n    '',\n    'vec2 fix( vec4 i, float aspect ) {',\n    '',\n    '    vec2 res = i.xy / i.w;',\n    '    res.x *= aspect;',\n    '\t vCounters = counters;',\n    '    return res;',\n    '',\n    '}',\n    '',\n    'void main() {',\n    '',\n    '    float aspect = resolution.x / resolution.y;',\n    '',\n    '    vColor = vec4( color, opacity );',\n    '    vUV = uv;',\n    '',\n    '    mat4 m = projectionMatrix * modelViewMatrix;',\n    '    vec4 finalPosition = m * vec4( position, 1.0 );',\n    '    vec4 prevPos = m * vec4( previous, 1.0 );',\n    '    vec4 nextPos = m * vec4( next, 1.0 );',\n    '',\n    '    vec2 currentP = fix( finalPosition, aspect );',\n    '    vec2 prevP = fix( prevPos, aspect );',\n    '    vec2 nextP = fix( nextPos, aspect );',\n    '',\n    '    float w = lineWidth * width;',\n    '',\n    '    vec2 dir;',\n    '    if( nextP == currentP ) dir = normalize( currentP - prevP );',\n    '    else if( prevP == currentP ) dir = normalize( nextP - currentP );',\n    '    else {',\n    '        vec2 dir1 = normalize( currentP - prevP );',\n    '        vec2 dir2 = normalize( nextP - currentP );',\n    '        dir = normalize( dir1 + dir2 );',\n    '',\n    '        vec2 perp = vec2( -dir1.y, dir1.x );',\n    '        vec2 miter = vec2( -dir.y, dir.x );',\n    '        //w = clamp( w / dot( miter, perp ), 0., 4. * lineWidth * width );',\n    '',\n    '    }',\n    '',\n    '    //vec2 normal = ( cross( vec3( dir, 0. ), vec3( 0., 0., 1. ) ) ).xy;',\n    '    vec4 normal = vec4( -dir.y, dir.x, 0., 1. );',\n    '    normal.xy *= .5 * w;',\n    '    normal *= projectionMatrix;',\n    '    if( sizeAttenuation == 0. ) {',\n    '        normal.xy *= finalPosition.w;',\n    '        normal.xy /= ( vec4( resolution, 0., 1. ) * projectionMatrix ).xy;',\n    '    }',\n    '',\n    '    vec4 offset = vec4( normal.xy * side, 0.0, 1.0 );',\n    '    finalPosition.xy += offset.xy;',\n    '',\n    '    gl_Position = finalPosition;',\n    '',\n    THREE.ShaderChunk.logdepthbuf_vertex,\n    THREE.ShaderChunk.fog_vertex && '    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );',\n    THREE.ShaderChunk.fog_vertex,\n    '}',\n  ].join('\\r\\n')\n\n  THREE.ShaderChunk['meshline_frag'] = [\n    '',\n    THREE.ShaderChunk.fog_pars_fragment,\n    THREE.ShaderChunk.logdepthbuf_pars_fragment,\n    '',\n    'uniform sampler2D map;',\n    'uniform sampler2D alphaMap;',\n    'uniform float useMap;',\n    'uniform float useAlphaMap;',\n    'uniform float useDash;',\n    'uniform float dashArray;',\n    'uniform float dashOffset;',\n    'uniform float dashRatio;',\n    'uniform float visibility;',\n    'uniform float alphaTest;',\n    'uniform vec2 repeat;',\n    '',\n    'varying vec2 vUV;',\n    'varying vec4 vColor;',\n    'varying float vCounters;',\n    '',\n    'void main() {',\n    '',\n    THREE.ShaderChunk.logdepthbuf_fragment,\n    '',\n    '    vec4 c = vColor;',\n    '    if( useMap == 1. ) c *= texture2D( map, vUV * repeat );',\n    '    if( useAlphaMap == 1. ) c.a *= texture2D( alphaMap, vUV * repeat ).a;',\n    '    if( c.a < alphaTest ) discard;',\n    '    if( useDash == 1. ){',\n    '        c.a *= ceil(mod(vCounters + dashOffset, dashArray) - (dashArray * dashRatio));',\n    '    }',\n    '    gl_FragColor = c;',\n    '    gl_FragColor.a *= step(vCounters, visibility);',\n    '',\n    THREE.ShaderChunk.fog_fragment,\n    '}',\n  ].join('\\r\\n')\n\n  function MeshLineMaterial(parameters) {\n    THREE.ShaderMaterial.call(this, {\n      uniforms: Object.assign({}, THREE.UniformsLib.fog, {\n        lineWidth: { value: 1 },\n        map: { value: null },\n        useMap: { value: 0 },\n        alphaMap: { value: null },\n        useAlphaMap: { value: 0 },\n        color: { value: new THREE.Color(0xffffff) },\n        opacity: { value: 1 },\n        resolution: { value: new THREE.Vector2(1, 1) },\n        sizeAttenuation: { value: 1 },\n        near: { value: 1 },\n        far: { value: 1 },\n        dashArray: { value: 0 },\n        dashOffset: { value: 0 },\n        dashRatio: { value: 0.5 },\n        useDash: { value: 0 },\n        visibility: { value: 1 },\n        alphaTest: { value: 0 },\n        repeat: { value: new THREE.Vector2(1, 1) },\n      }),\n\n      vertexShader: THREE.ShaderChunk.meshline_vert,\n\n      fragmentShader: THREE.ShaderChunk.meshline_frag,\n    })\n\n    this.type = 'MeshLineMaterial'\n\n    Object.defineProperties(this, {\n      lineWidth: {\n        enumerable: true,\n        get: function() {\n          return this.uniforms.lineWidth.value\n        },\n        set: function(value) {\n          this.uniforms.lineWidth.value = value\n        },\n      },\n      map: {\n        enumerable: true,\n        get: function() {\n          return this.uniforms.map.value\n        },\n        set: function(value) {\n          this.uniforms.map.value = value\n        },\n      },\n      useMap: {\n        enumerable: true,\n        get: function() {\n          return this.uniforms.useMap.value\n        },\n        set: function(value) {\n          this.uniforms.useMap.value = value\n        },\n      },\n      alphaMap: {\n        enumerable: true,\n        get: function() {\n          return this.uniforms.alphaMap.value\n        },\n        set: function(value) {\n          this.uniforms.alphaMap.value = value\n        },\n      },\n      useAlphaMap: {\n        enumerable: true,\n        get: function() {\n          return this.uniforms.useAlphaMap.value\n        },\n        set: function(value) {\n          this.uniforms.useAlphaMap.value = value\n        },\n      },\n      color: {\n        enumerable: true,\n        get: function() {\n          return this.uniforms.color.value\n        },\n        set: function(value) {\n          this.uniforms.color.value = value\n        },\n      },\n      opacity: {\n        enumerable: true,\n        get: function() {\n          return this.uniforms.opacity.value\n        },\n        set: function(value) {\n          this.uniforms.opacity.value = value\n        },\n      },\n      resolution: {\n        enumerable: true,\n        get: function() {\n          return this.uniforms.resolution.value\n        },\n        set: function(value) {\n          this.uniforms.resolution.value.copy(value)\n        },\n      },\n      sizeAttenuation: {\n        enumerable: true,\n        get: function() {\n          return this.uniforms.sizeAttenuation.value\n        },\n        set: function(value) {\n          this.uniforms.sizeAttenuation.value = value\n        },\n      },\n      near: {\n        enumerable: true,\n        get: function() {\n          return this.uniforms.near.value\n        },\n        set: function(value) {\n          this.uniforms.near.value = value\n        },\n      },\n      far: {\n        enumerable: true,\n        get: function() {\n          return this.uniforms.far.value\n        },\n        set: function(value) {\n          this.uniforms.far.value = value\n        },\n      },\n      dashArray: {\n        enumerable: true,\n        get: function() {\n          return this.uniforms.dashArray.value\n        },\n        set: function(value) {\n          this.uniforms.dashArray.value = value\n          this.useDash = value !== 0 ? 1 : 0\n        },\n      },\n      dashOffset: {\n        enumerable: true,\n        get: function() {\n          return this.uniforms.dashOffset.value\n        },\n        set: function(value) {\n          this.uniforms.dashOffset.value = value\n        },\n      },\n      dashRatio: {\n        enumerable: true,\n        get: function() {\n          return this.uniforms.dashRatio.value\n        },\n        set: function(value) {\n          this.uniforms.dashRatio.value = value\n        },\n      },\n      useDash: {\n        enumerable: true,\n        get: function() {\n          return this.uniforms.useDash.value\n        },\n        set: function(value) {\n          this.uniforms.useDash.value = value\n        },\n      },\n      visibility: {\n        enumerable: true,\n        get: function() {\n          return this.uniforms.visibility.value\n        },\n        set: function(value) {\n          this.uniforms.visibility.value = value\n        },\n      },\n      alphaTest: {\n        enumerable: true,\n        get: function() {\n          return this.uniforms.alphaTest.value\n        },\n        set: function(value) {\n          this.uniforms.alphaTest.value = value\n        },\n      },\n      repeat: {\n        enumerable: true,\n        get: function() {\n          return this.uniforms.repeat.value\n        },\n        set: function(value) {\n          this.uniforms.repeat.value.copy(value)\n        },\n      },\n    })\n\n    this.setValues(parameters)\n  }\n\n  MeshLineMaterial.prototype = Object.create(THREE.ShaderMaterial.prototype)\n  MeshLineMaterial.prototype.constructor = MeshLineMaterial\n  MeshLineMaterial.prototype.isMeshLineMaterial = true\n\n  MeshLineMaterial.prototype.copy = function(source) {\n    THREE.ShaderMaterial.prototype.copy.call(this, source)\n\n    this.lineWidth = source.lineWidth\n    this.map = source.map\n    this.useMap = source.useMap\n    this.alphaMap = source.alphaMap\n    this.useAlphaMap = source.useAlphaMap\n    this.color.copy(source.color)\n    this.opacity = source.opacity\n    this.resolution.copy(source.resolution)\n    this.sizeAttenuation = source.sizeAttenuation\n    this.near = source.near\n    this.far = source.far\n    this.dashArray.copy(source.dashArray)\n    this.dashOffset.copy(source.dashOffset)\n    this.dashRatio.copy(source.dashRatio)\n    this.useDash = source.useDash\n    this.visibility = source.visibility\n    this.alphaTest = source.alphaTest\n    this.repeat.copy(source.repeat)\n\n    return this\n  }\n\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = {\n        MeshLine: MeshLine,\n        MeshLineMaterial: MeshLineMaterial,\n        MeshLineRaycast: MeshLineRaycast,\n      }\n    }\n    exports.MeshLine = MeshLine\n    exports.MeshLineMaterial = MeshLineMaterial\n    exports.MeshLineRaycast = MeshLineRaycast\n  } else {\n    root.MeshLine = MeshLine\n    root.MeshLineMaterial = MeshLineMaterial\n    root.MeshLineRaycast = MeshLineRaycast\n  }\n}.call(this))\n"],"sourceRoot":""}